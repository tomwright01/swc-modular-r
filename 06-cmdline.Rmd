---
layout: lesson
root: ../..
---

```{r, include = FALSE}
source("chunk_options.R")
```

## Command-Line Programs

The R Console and other interactive tools like RStudio are great for prototyping code and exploring data, but sooner or later we will want to use our program in a pipeline or run it in a shell script to process thousands of data files.
In order to do that, we need to make our programs work like other Unix command-line tools.
For example, we may want a program that reads a data set and prints the average inflammation per patient:

~~~
$ Rscript readings.R --mean inflammation-01.csv
5.45
5.425
6.1
...
6.4
7.05
5.9
~~~

but we might also want to look at the minimum of the first four lines

~~~
$ head -4 inflammation-01.csv | Rscript readings.R --min
~~~

or the maximum inflammations in several files one after another:

~~~
$ Rscript readings.py --max inflammation-*.csv
~~~

Our overall requirements are:

1. If no filename is given on the command line, read data from [standard input](../../gloss.html#standard-input).
2. If one or more filenames are given, read data from them and report statistics for each file separately.
3. Use the `--min`, `--mean`, or `--max` flag to determine what statistic to print.

To make this work, we need to know how to handle command-line arguments in a program, and how to get at standard input.
We'll tackle these questions in turn below.

<div class="objectives" markdown="1">
#### Objectives

*   Use the values of command-line arguments in a program.
*   Handle flags and files separately in a command-line program.
*   Read data from standard input in a program so that it can be used in a pipeline.
</div>

### Command-Line Arguments

Using the text editor of your choice, save the following line of code in a text file called `session-info.R `:

```{r echo=FALSE, engine='bash'}
cat session-info.R
```

The function, `sessionInfo`, outputs the version of R you are running as well as the type of computer you are using (as well as the versions of the packages that have been loaded).
This is very useful information to include when asking others for help with your R code.

Now we can run the code in the file we created from the Unix Shell using `Rscript`:

```{r engine='bash'}
Rscript session-info.R
```

> **Tip:** If that did not work, remember that you must be in the correct directory.
You can determine which directory you are currently in using `pwd` and change to a different directory using `cd`.
For a review, see this [lesson](../shell/01-filedir.html) or the [Unix Shell Reference](../ref/01-shell.html).

Now let's create another script that does something more interesting. Write the following lines in a file named `print-args.R`:

```{r echo=FALSE, engine='bash'}
cat print-args.R
```

The function `commandArgs` extracts all the command line arguments and returns them as a vector.
Let's see what happens when we run this program in the Unix Shell:

```{r engine='bash'}
Rscript print-args.R
```

From this output, we learn that `Rscript` is just a convenience command for running R scripts.
The first argument in the vector is the path to the `R` executable.
The following are all command-line arguments that affect the behavior of R.
From the R help file:

*  `--slave`: Make R run as quietly as possible
*  `--no-restore`:  Don't restore anything that was created during the R session
*  `--file`: Run this file
*  `--args`: Pass these argments to the file being run

Thus running a file with Rscript is an easier way to run the following:

```{r engine='bash'}
R --slave --no-restore --file=print-args.R --args
```

If we run it with a few arguments, however:

```{r engine='bash'}
Rscript print-args.R first second third
```

then `commandArgs` adds each of those arguments to the vector it returns.
Since the first elements of the vector are always the same, we can tell `commandArgs` to only return the arguments that come after `--args`.
Let's update `print-args.R` and save it as `print-args-trailing.R`:

```{r echo=FALSE, engine='bash'}
cat print-args-trailing.R
```

And then run `print-args-trailing` from the Unix Shell:

```{r engine='bash'}
Rscript print-args-trailing.R first second third
```

Now `commandArgs` returns only the arguments that we listed after `print-args-trailing.R`.

With this in hand, let's build a version of `readings.py` that always prints the per-patient (per-row) mean of a single data file.
The first step is to write a function that outlines our implementation, and a placeholder for the function that does the actual work.
By convention this function is usually called `main`, though we can call it whatever we want.
Write the following code in a file called `readings-01.R`:

```{r echo=FALSE, engine='bash'}
cat readings-01.R
```


This function gets the name of the file to process from the first element returned by `commandArgs`.
Here's a simple test to run from the Unix Shell:

```{r engine='bash'}
Rscript readings-01.R inflammation-01.csv
```

There is no output because we have defined a function, but haven't actually called it.
Let's add a call to `main` and save it as `readings-02.R`:

```{r echo=FALSE, engine='bash'}
cat readings-02.R
```

```{r engine='bash'}
Rscript readings-02.R inflammation-01.csv
```
